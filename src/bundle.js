/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/front_end/bot/main.ts":
/*!***********************************!*\
  !*** ./src/front_end/bot/main.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BotMakeMove = exports.CreateBot = void 0;\nconst CreateBot = () => {\n    const script = document.createElement('script');\n    script.src = 'src/front_end/bot/engine.js';\n    document.head.appendChild(script);\n    let isReady = false;\n    script.onload = () => {\n        if (typeof Module === 'undefined') {\n            console.error('Module is not defined. Ensure the WASM environment is properly set up.');\n            return;\n        }\n        Module.onRuntimeInitialized = () => {\n            isReady = true;\n        };\n    };\n    const IsReady = () => {\n        return isReady;\n    };\n    return { IsReady };\n};\nexports.CreateBot = CreateBot;\nconst BotMakeMove = (game, depth) => {\n    // Create a pointer to a 'Board' structure in WASM memory\n    const boardSize = 25 * 8; // 25 tiles, each 2 bytes (2 uint8)\n    const boardPtr = Module._malloc(boardSize);\n    const height = game.GetHeight();\n    const width = game.GetWidth();\n    let i = 0;\n    for (let y = 0; y < height; y++) {\n        for (let x = 0; x < width; x++) {\n            const tile = game.GetTile(x, y);\n            Module.setValue(boardPtr + i, tile.player, 'i8');\n            Module.setValue(boardPtr + (i + 1), tile.dots, 'i8');\n            i += 2;\n        }\n    }\n    // Wrap the `InitialiseMiniMax` function\n    const InitBotEngine = Module.cwrap('InitBotEngine', 'number', [\n        'number',\n        'number',\n        'number',\n        'number'\n    ]);\n    // Call the function\n    const result = InitBotEngine(boardPtr, depth, game.GetRound(), game.GetCurrentPlayerIndex());\n    // Free the allocated memory\n    Module._free(boardPtr);\n    // console.log('result', result)\n    if (result < 0 || result >= 25) {\n        console.error('Computer did not pick a move');\n        return null;\n    }\n    else {\n        const x = result % 5;\n        const y = Math.floor(result / 5);\n        // console.log('Computer picked', x, y);\n        return [x, y];\n    }\n};\nexports.BotMakeMove = BotMakeMove;\n\n\n//# sourceURL=webpack:///./src/front_end/bot/main.ts?");

/***/ }),

/***/ "./src/front_end/build_time.ts":
/*!*************************************!*\
  !*** ./src/front_end/build_time.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BUILD_TIME = void 0;\nexports.BUILD_TIME = new Date('2024-12-24T11:41:54.239Z');\n\n\n//# sourceURL=webpack:///./src/front_end/build_time.ts?");

/***/ }),

/***/ "./src/front_end/dom/main.ts":
/*!***********************************!*\
  !*** ./src/front_end/dom/main.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.InitialiseElementEvents = void 0;\nconst build_time_1 = __webpack_require__(/*! ../build_time */ \"./src/front_end/build_time.ts\");\nconst main_1 = __webpack_require__(/*! ../game/main */ \"./src/front_end/game/main.ts\");\nconst utils_1 = __webpack_require__(/*! ../utils */ \"./src/front_end/utils.ts\");\nconst types_1 = __webpack_require__(/*! ./types */ \"./src/front_end/dom/types.ts\");\nconst localStorageKeys = {\n    botDepth: 'botDepth',\n    botWaitPeriod: 'botWaitPeriod',\n    tileUpdatePeriod: 'tileUpdatePeriod',\n    player: (index) => `player${index}`,\n    scoreRecords: 'scoreRecords'\n};\nconst InitialiseElements = () => {\n    const elementNames = [\n        // pages\n        'pageMenu',\n        'pageSettings',\n        'pageScoreRecords',\n        'pageNewGame',\n        'pageGame',\n        // players\n        'player1User',\n        'player2User',\n        // components\n        'newGame',\n        'gotoHome',\n        'botDepth',\n        'botDepthMinus',\n        'resetStorage',\n        'gameTimer',\n        'botStatus',\n        'gameIteration',\n        'scoreRecords',\n        'board',\n        'openPageNewGame',\n        'openPageScoreRecords',\n        'openPageSettings',\n        'version',\n        'botWaitPeriod',\n        'tileUpdatePeriod',\n        'botWaitPeriodMinus',\n        'tileUpdatePeriodMinus'\n    ];\n    const elements = Object.fromEntries(elementNames.map(name => [name, document.getElementById(name)]));\n    const nullElements = Object.keys(elements).filter(key => elements[key] === null);\n    if (nullElements.length > 0) {\n        throw new Error(`Not all HTML Elements could be located:\\n${JSON.stringify(nullElements)}`);\n    }\n    return {\n        pages: {\n            Menu: elements['pageMenu'],\n            NewGame: elements['pageNewGame'],\n            Settings: elements['pageSettings'],\n            ScoreRecords: elements['pageScoreRecords'],\n            Game: elements['pageGame']\n        },\n        newGame: elements['newGame'],\n        gotoHome: elements['gotoHome'],\n        players: [\n            elements['player1User'],\n            elements['player2User']\n        ],\n        botDepth: elements['botDepth'],\n        botDepthMinus: elements['botDepthMinus'],\n        resetStorage: elements['resetStorage'],\n        gameTimer: elements['gameTimer'],\n        botStatus: elements['botStatus'],\n        round: elements['gameIteration'],\n        scoreboard: elements['scoreRecords'],\n        board: elements['board'],\n        openPageNewGame: elements['openPageNewGame'],\n        openPageScoreRecords: elements['openPageScoreRecords'],\n        openPageSettings: elements['openPageSettings'],\n        version: elements['version'],\n        botWaitPeriod: elements['botWaitPeriod'],\n        tileUpdatePeriod: elements['tileUpdatePeriod'],\n        botWaitPeriodMinus: elements['botWaitPeriodMinus'],\n        tileUpdatePeriodMinus: elements['tileUpdatePeriodMinus']\n    };\n};\nconst SetElementVisibility = (element, visible) => {\n    if (visible) {\n        element.classList.remove('hide');\n    }\n    else {\n        element.classList.add('hide');\n    }\n};\nconst GetLocalStorageItem = (key, defaultValue) => {\n    if (localStorage.getItem(key) === null) {\n        localStorage.setItem(key, defaultValue);\n        return defaultValue;\n    }\n    else {\n        return localStorage.getItem(key);\n    }\n};\nconst CyclePlayerOption = (playerIndex) => {\n    const element = elements.players[playerIndex];\n    const playerOptionIndex = (playerOptions.findIndex(item => item === element.textContent) + 1) %\n        playerOptions.length;\n    element.textContent = playerOptions[playerOptionIndex];\n    localStorage.setItem(localStorageKeys.player(playerIndex), element.textContent);\n};\nconst CyclicCounterManager = (min, max, defaultValue, increment, name, onChangeCallback) => {\n    const minusElement = elements[(name + 'Minus')];\n    const plusElement = elements[name]; // also display element\n    const storageKey = localStorageKeys[name];\n    const Initialise = () => {\n        plusElement.textContent = GetLocalStorageItem(storageKey, String(defaultValue));\n        onChangeCallback(defaultValue);\n    };\n    Initialise();\n    resetStorageCallbackHandler.addCallback(Initialise);\n    const CycleCounter = (increment) => {\n        let value = Number(plusElement.textContent);\n        value += increment;\n        if (value < min) {\n            value = max;\n        }\n        else if (value > max) {\n            value = min;\n        }\n        const valueStr = String(value);\n        plusElement.textContent = valueStr;\n        localStorage.setItem(storageKey, valueStr);\n        onChangeCallback(value);\n    };\n    plusElement.onclick = () => CycleCounter(increment);\n    minusElement.onclick = () => CycleCounter(-increment);\n};\nvar PlayerOption;\n(function (PlayerOption) {\n    PlayerOption[\"User\"] = \"User\";\n    PlayerOption[\"Bot\"] = \"Bot\";\n})(PlayerOption || (PlayerOption = {}));\nconst playerOptions = [PlayerOption.User, PlayerOption.Bot];\nconst MakePlayer = (playerIndex) => {\n    const playerOption = elements.players[playerIndex]\n        .textContent;\n    if (playerOption === PlayerOption.User) {\n        return (0, main_1.NewPlayerUser)();\n    }\n    else {\n        const botSearchDepth = Number(elements.botDepth.textContent);\n        return (0, main_1.NewPlayerBot)(botSearchDepth);\n    }\n};\nconst InitialiseElementsPoweredByLocalStorage = () => {\n    elements.players[0].textContent = GetLocalStorageItem(localStorageKeys.player(0), PlayerOption.Bot);\n    elements.players[1].textContent = GetLocalStorageItem(localStorageKeys.player(1), PlayerOption.User);\n};\nconst CreatePageManager = (initialPage) => {\n    let currentPage = initialPage;\n    const GetPage = () => {\n        return currentPage;\n    };\n    const SetPage = (page) => {\n        if (page === currentPage) {\n            console.warn(`Attempting to set page to current page ${page}`);\n            return;\n        }\n        // only show goto home button when not on home page\n        SetElementVisibility(elements.gotoHome, page !== types_1.Page.Menu);\n        SetElementVisibility(elements.pages[currentPage], false);\n        SetElementVisibility(elements.pages[page], true);\n        currentPage = page;\n    };\n    return {\n        GetPage,\n        SetPage\n    };\n};\nconst resetStorageCallbackHandler = (0, utils_1.NewCallbackHandler)();\nconst InitialiseElementEvents = (game, bot) => {\n    const pageManager = CreatePageManager(types_1.Page.Menu);\n    game.AddNewRoundCallback(() => {\n        const playerIndex = game.GetCurrentPlayerIndex();\n        elements.botStatus.style.backgroundColor = GetPlayerColor(playerIndex);\n    });\n    game.AddRenderCallback(() => {\n        UpdateBoard(game);\n        const playerMoves = game.GetPlayerMoves();\n        if (playerMoves.length > 0) {\n            const playerIndex = game.GetCurrentPlayerIndex();\n            RemoveLastPlayerMoveStyle();\n            const { x, y } = playerMoves.at(-1);\n            const tileElement = GetTileElement(x, y);\n            tileElement.classList.add(`lastMoveOfPlayer${playerIndex + 1}`);\n        }\n    });\n    game.AddEndOfGameCallback(() => {\n        const playerIndex = game.GetCurrentPlayerIndex();\n        elements.botStatus.textContent = `Player ${playerIndex === 0 ? 'One' : 'Two'} has Won!`;\n        RenderScoreRecords(game);\n    });\n    elements.newGame.onclick = () => {\n        if (!bot.IsReady()) {\n            console.warn('Bot is not ready for a new game');\n        }\n        const width = 5;\n        const height = 5;\n        game.NewGame(width, height, MakePlayer(0), MakePlayer(1));\n        InitialiseBoard(game);\n        InitialiseUpdateTeamElapsedTime(game);\n        UpdateBoard(game);\n        RemoveLastPlayerMoveStyle();\n        pageManager.SetPage(types_1.Page.Game);\n    };\n    elements.gotoHome.onclick = () => {\n        pageManager.SetPage(types_1.Page.Menu);\n        game.TerminateGame();\n    };\n    elements.openPageNewGame.onclick = () => {\n        pageManager.SetPage(types_1.Page.NewGame);\n    };\n    elements.openPageScoreRecords.onclick = () => {\n        pageManager.SetPage(types_1.Page.ScoreRecords);\n    };\n    elements.openPageSettings.onclick = () => {\n        pageManager.SetPage(types_1.Page.Settings);\n    };\n    elements.players.forEach((element, index) => (element.onclick = () => CyclePlayerOption(index)));\n    elements.version.textContent = `Version ${VERSION} (Build ${(0, utils_1.FormatDate)(build_time_1.BUILD_TIME)})`;\n    CyclicCounterManager(1, 16, 8, 1, 'botDepth', () => { });\n    CyclicCounterManager(0, 2000, 500, 50, 'botWaitPeriod', game.SetBotWaitPeriod);\n    CyclicCounterManager(0, 2000, 500, 50, 'tileUpdatePeriod', game.SetTileUpdatePeriod);\n    InitialiseElementsPoweredByLocalStorage();\n    RenderScoreRecords(game);\n    resetStorageCallbackHandler.addCallback(InitialiseElementsPoweredByLocalStorage);\n    resetStorageCallbackHandler.addCallback(() => RenderScoreRecords(game));\n    elements.resetStorage.onclick = () => {\n        localStorage.clear();\n        resetStorageCallbackHandler.triggerCallbacks();\n    };\n};\nexports.InitialiseElementEvents = InitialiseElementEvents;\nconst RenderScoreRecords = (game) => {\n    const scoreRecords = game.GetScoreRecords();\n    elements.scoreboard.innerHTML = '';\n    if (Object.keys(scoreRecords).length === 0) {\n        elements.scoreboard.innerHTML = 'No records';\n        return;\n    }\n    const div = document.createElement('div');\n    div.className = 'record';\n    div.innerHTML = `<div>Players</div><div>Winner</div><div>Round</div>`;\n    elements.scoreboard.appendChild(div);\n    Object.keys(scoreRecords).forEach(key => {\n        const scoreRecord = scoreRecords[key];\n        if (scoreRecord === null) {\n            return;\n        }\n        const div = document.createElement('div');\n        div.className = 'record';\n        div.innerHTML = `<div>${key}</div><div>${scoreRecord.winningPlayerIndex === 0 ? 'One' : 'Two'}</div><div>${scoreRecord.round}</div>`;\n        elements.scoreboard.appendChild(div);\n    });\n};\nconst GetTileElementId = (x, y) => {\n    return `tile${x}_${y}`;\n};\nconst RemoveClassFromElementByPrefix = (element, prefix) => {\n    const totalDotsClass = Array.from(element.classList).find(className => className.startsWith(prefix));\n    if (totalDotsClass) {\n        element.classList.remove(totalDotsClass);\n    }\n};\nconst GetTileElement = (x, y) => {\n    const tileElement = document.getElementById(GetTileElementId(x, y));\n    if (tileElement === null) {\n        throw new Error(`Tile element at (${x}, ${y}) is null`);\n    }\n    return tileElement;\n};\nconst GetDotElementOfTile = (x, y, dot) => {\n    const tileElement = document.getElementById(GetTileElementId(x, y));\n    if (tileElement === null) {\n        throw new Error(`Tile element at (${x}, ${y}) is null`);\n    }\n    const dotElements = tileElement.getElementsByClassName(`dotNo${dot}`);\n    if (dotElements.length !== 1) {\n        throw new Error(`Expected exactly one dot element with ${dot} dots at tile (${x}, ${y})`);\n    }\n    const dotElement = dotElements[0];\n    return dotElement;\n};\nconst GetPlayerColor = (playerIndex, delta = 0) => {\n    const lightness = Math.floor(Math.random() * delta + (50 - delta / 2));\n    const hue = playerIndex === 0 ? 0 : 135;\n    const color = `hsl(${hue}, 100%, ${lightness}%)`;\n    return color;\n};\nconst UpdateTile = (x, y, tile) => {\n    for (let dot = 1; dot <= tile.dots; dot++) {\n        const dotElement = GetDotElementOfTile(x, y, dot);\n        dotElement.style.opacity = '1';\n        RemoveClassFromElementByPrefix(dotElement, 'totalDots');\n        RemoveClassFromElementByPrefix(dotElement, 'dotNo');\n        dotElement.classList.add(`totalDots${tile.dots}`);\n        dotElement.classList.add(`dotNo${dot}`);\n        dotElement.style.backgroundColor = GetPlayerColor(tile.player, 0);\n    }\n    for (let dot = tile.dots + 1; dot <= 4; dot++) {\n        const dotElement = GetDotElementOfTile(x, y, dot);\n        dotElement.style.opacity = '0';\n        RemoveClassFromElementByPrefix(dotElement, 'totalDots');\n    }\n};\nconst UpdateRound = (game) => {\n    const round = Math.floor(game.GetRound() / 2) + 1;\n    elements.round.textContent = `Round ${round}`;\n};\nconst UpdateBoard = (game) => {\n    const height = game.GetHeight();\n    const width = game.GetWidth();\n    for (let y = 0; y < height; y++) {\n        for (let x = 0; x < width; x++) {\n            const tile = game.GetTile(x, y);\n            UpdateTile(x, y, tile);\n        }\n    }\n    UpdateRound(game);\n};\nconst RemoveLastPlayerMoveStyle = () => {\n    for (const i of [1, 2]) {\n        const clsName = `lastMoveOfPlayer${i}`;\n        for (let tile of document.getElementsByClassName(clsName)) {\n            tile.classList.remove(clsName);\n        }\n    }\n};\nconst InitialiseBoard = (game) => {\n    const height = game.GetHeight();\n    const width = game.GetWidth();\n    // delete board children\n    while (elements.board.firstChild) {\n        elements.board.removeChild(elements.board.firstChild);\n    }\n    for (let y = 0; y < height; y++) {\n        for (let x = 0; x < width; x++) {\n            const tileElement = document.createElement('div');\n            tileElement.className = 'tile';\n            tileElement.id = GetTileElementId(x, y);\n            for (let dot = 1; dot <= 4; dot++) {\n                const dotElement = document.createElement('div');\n                dotElement.classList.add('dot');\n                dotElement.classList.add(`dotNo${dot}`);\n                dotElement.style.opacity = '0';\n                tileElement.appendChild(dotElement);\n            }\n            const randomColor = `hsl(30, 3%, ${Math.floor(Math.random() * 6) + 23}%)`; // Random HSL color\n            tileElement.style.backgroundColor = randomColor;\n            tileElement.onclick = async () => {\n                const canPlayerMove = game.CanPlayerMove(x, y);\n                if (!canPlayerMove) {\n                    return;\n                }\n                await game.MakePlayerMove(x, y);\n                UpdateRound(game);\n            };\n            elements.board.appendChild(tileElement);\n        }\n    }\n};\nconst InitialiseUpdateTeamElapsedTime = (game) => {\n    // TODO: move player time record into game\n    let playerElapsedTimes = [0, 0];\n    let lastTime = performance.now();\n    let startOfRoundTime = lastTime;\n    let lastRound = 0;\n    const UpdateTeamElapsedTime = () => {\n        if (game.GetHasGameEnded()) {\n            return;\n        }\n        const now = performance.now();\n        const playerIndex = game.GetCurrentPlayerIndex();\n        if (lastRound !== game.GetRound()) {\n            startOfRoundTime = now;\n            lastRound = game.GetRound();\n        }\n        playerElapsedTimes[playerIndex] += now - lastTime;\n        lastTime = now;\n        elements.gameTimer.textContent =\n            (0, utils_1.millisToMMSS)(playerElapsedTimes[0]) +\n                ' - ' +\n                (0, utils_1.millisToMMSS)(playerElapsedTimes[1]);\n        elements.botStatus.textContent = `Player ${playerIndex === 0 ? 'One' : 'Two'} (${(0, utils_1.millisToMMSS)(now - startOfRoundTime)})`;\n        requestAnimationFrame(UpdateTeamElapsedTime);\n    };\n    UpdateTeamElapsedTime();\n};\nconst ResetStorageOnVersionChange = () => {\n    if (localStorage.getItem('version') !== VERSION) {\n        console.log('Version changed, resetting storage');\n        localStorage.clear();\n        localStorage.setItem('version', VERSION);\n    }\n};\nconst VERSION = '2'; // if version changes, reset storage\nResetStorageOnVersionChange();\nconst elements = InitialiseElements();\n\n\n//# sourceURL=webpack:///./src/front_end/dom/main.ts?");

/***/ }),

/***/ "./src/front_end/dom/types.ts":
/*!************************************!*\
  !*** ./src/front_end/dom/types.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Page = void 0;\nvar Page;\n(function (Page) {\n    Page[\"Menu\"] = \"Menu\";\n    Page[\"Settings\"] = \"Settings\";\n    Page[\"ScoreRecords\"] = \"ScoreRecords\";\n    Page[\"NewGame\"] = \"NewGame\";\n    Page[\"Game\"] = \"Game\";\n})(Page || (exports.Page = Page = {}));\n\n\n//# sourceURL=webpack:///./src/front_end/dom/types.ts?");

/***/ }),

/***/ "./src/front_end/game/main.ts":
/*!************************************!*\
  !*** ./src/front_end/game/main.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CreateGame = exports.NewTile = exports.NewPlayerBot = exports.NewPlayerUser = void 0;\nconst main_1 = __webpack_require__(/*! ../bot/main */ \"./src/front_end/bot/main.ts\");\nconst types_1 = __webpack_require__(/*! ./types */ \"./src/front_end/game/types.ts\");\nconst utils_1 = __webpack_require__(/*! ../utils */ \"./src/front_end/utils.ts\");\n// GAME\nconst LOCAL_STORAGE_SCORE_RECORDS = 'score_records';\nconst NewScoreRecord = (round, winningPlayerIndex) => {\n    return { round, winningPlayerIndex };\n};\nconst NewPlayerUser = (name = 'User') => {\n    return { type: types_1.PlayerType.User, name };\n};\nexports.NewPlayerUser = NewPlayerUser;\nconst NewPlayerBot = (searchDepth) => {\n    return { type: types_1.PlayerType.Bot, searchDepth };\n};\nexports.NewPlayerBot = NewPlayerBot;\nconst IsPlayerUser = (player) => {\n    return player.type === types_1.PlayerType.User;\n};\nconst IsPlayerBot = (player) => {\n    return player.type === types_1.PlayerType.Bot;\n};\nconst PlayerToIdentifier = (player) => {\n    if (IsPlayerUser(player)) {\n        return `${player.name}`;\n    }\n    else if (IsPlayerBot(player)) {\n        return `Bot[${player.searchDepth}]`;\n    }\n    throw Error(`PlayerToIdentifier(${player}) not implemented`);\n};\nconst NewTile = (dots, player) => {\n    return { dots, player };\n};\nexports.NewTile = NewTile;\nconst CreateGame = () => {\n    const tiles = [];\n    let round = 0;\n    let hasGameEnded = true;\n    let isPlayerMoving = false;\n    let _tileUpdatePeriod = 500; // milliseconds\n    let _botWaitPeriod = 500; // milliseconds\n    let _width = 0;\n    let _height = 0;\n    const playerMoves = [];\n    const players = [];\n    const renderCallbackHandler = (0, utils_1.NewCallbackHandler)();\n    const newRoundCallbackHandler = (0, utils_1.NewCallbackHandler)();\n    const endOfGameCallbackHandler = (0, utils_1.NewCallbackHandler)();\n    const MakeComputerMove = async () => {\n        const nextPlayer = players[GetCurrentPlayerIndex()];\n        if (IsPlayerBot(nextPlayer)) {\n            await (0, utils_1.Sleep)(_botWaitPeriod);\n            const result = (0, main_1.BotMakeMove)(state, nextPlayer.searchDepth);\n            if (result) {\n                const [x, y] = result;\n                MakePlayerMove(x, y);\n            }\n        }\n    };\n    newRoundCallbackHandler.addCallback(MakeComputerMove);\n    const SetTileUpdatePeriod = (tileUpdatePeriod) => {\n        _tileUpdatePeriod = tileUpdatePeriod;\n    };\n    const SetBotWaitPeriod = (botWaitPeriod) => {\n        _botWaitPeriod = botWaitPeriod;\n    };\n    const NewGame = async (width, height, playerOne, playerTwo) => {\n        if (!hasGameEnded) {\n            TerminateGame();\n        }\n        _width = width;\n        _height = height;\n        // length=0 empties the array\n        playerMoves.length = 0;\n        tiles.length = 0;\n        round = 0;\n        hasGameEnded = false;\n        // pass players as args\n        players[0] = playerOne;\n        players[1] = playerTwo;\n        for (let y = 0; y < height; y++) {\n            for (let x = 0; x < width; x++) {\n                tiles.push((0, exports.NewTile)(0, 0));\n            }\n        }\n        newRoundCallbackHandler.triggerCallbacks();\n    };\n    const TerminateGame = () => {\n        hasGameEnded = true;\n        endOfGameCallbackHandler.triggerCallbacks();\n    };\n    const GetCurrentPlayerIndex = () => {\n        return round % 2;\n    };\n    const GetPlayerMoves = () => {\n        return playerMoves;\n    };\n    const IsValidTilePosition = (x, y) => {\n        return !(x < 0 || x >= _width || y < 0 || y >= _height);\n    };\n    const GetOptionalTile = (x, y) => {\n        if (!IsValidTilePosition(x, y)) {\n            return null;\n        }\n        return tiles[x + y * _width];\n    };\n    const GetTile = (x, y) => {\n        if (!IsValidTilePosition(x, y)) {\n            throw Error(`GetTile(${x}, ${y}) invalid position`);\n        }\n        return tiles[x + y * _width];\n    };\n    const SetTile = (x, y, tile) => {\n        if (!IsValidTilePosition(x, y)) {\n            throw Error(`SetTile(${x}, ${y}) invalid position`);\n        }\n        tiles[x + y * _width] = tile;\n    };\n    const PlayerSetTile = (x, y, tile) => {\n        SetTile(x, y, tile);\n        playerMoves.push({ x, y });\n    };\n    const TakeOverTile = (x, y, player) => {\n        const tile = GetOptionalTile(x, y);\n        if (tile === null) {\n            return;\n        }\n        const dots = Math.min(tile.dots + 1, 4);\n        SetTile(x, y, (0, exports.NewTile)(dots, player));\n    };\n    const GetTileUpdateCallbacks = () => {\n        let callbacks = [];\n        for (let y = 0; y < _height; y++) {\n            for (let x = 0; x < _width; x++) {\n                const tile = GetTile(x, y);\n                if (tile.dots >= 4) {\n                    callbacks.push(() => {\n                        SetTile(x, y, (0, exports.NewTile)(0, tile.player));\n                        TakeOverTile(x + 1, y, tile.player);\n                        TakeOverTile(x - 1, y, tile.player);\n                        TakeOverTile(x, y + 1, tile.player);\n                        TakeOverTile(x, y - 1, tile.player);\n                    });\n                }\n            }\n        }\n        return callbacks;\n    };\n    const UpdateTilesOneIteration = async () => {\n        const callbacks = GetTileUpdateCallbacks();\n        if (callbacks.length > 0) {\n            await (0, utils_1.Sleep)(_tileUpdatePeriod);\n            for (const callback of callbacks) {\n                callback();\n            }\n            return true;\n        }\n        return false;\n    };\n    const UpdateTiles = async () => {\n        while (await UpdateTilesOneIteration()) {\n            renderCallbackHandler.triggerCallbacks();\n        }\n    };\n    const GetPlayerScores = () => {\n        let score = [0, 0]; // player 1, player 2\n        for (let y = 0; y < _height; y++) {\n            for (let x = 0; x < _width; x++) {\n                const tile = GetTile(x, y);\n                score[tile.player] += tile.dots;\n            }\n        }\n        return score;\n    };\n    const UpdateGameIteration = () => {\n        const playerScores = GetPlayerScores();\n        const _hasGameEnded = round >= 2 && playerScores.some(score => score === 0);\n        if (_hasGameEnded) {\n            const winningPlayerIndex = playerScores[1] === 0 ? 0 : 1;\n            UpdateScoreRecords(winningPlayerIndex);\n            TerminateGame();\n        }\n        if (hasGameEnded) {\n            return;\n        }\n        round++;\n        newRoundCallbackHandler.triggerCallbacks();\n    };\n    const GetScoreRecords = () => {\n        const scoreRecordString = localStorage.getItem(LOCAL_STORAGE_SCORE_RECORDS);\n        const scoreRecords = scoreRecordString === null ? {} : JSON.parse(scoreRecordString);\n        return scoreRecords;\n    };\n    const UpdateScoreRecords = (winningPlayerIndex) => {\n        const playersIdentifer = players\n            .map(player => PlayerToIdentifier(player))\n            .join(' Vs ');\n        const scoreRecords = GetScoreRecords();\n        let previousScoreRecord = scoreRecords[playersIdentifer] || NewScoreRecord(0, 0);\n        let doUpdateRecord = false;\n        if (players.some(IsPlayerUser) && players.some(IsPlayerBot)) {\n            const playerIndexOfUser = players.findIndex(IsPlayerUser);\n            const didUserWin = playerIndexOfUser == winningPlayerIndex;\n            const hasUserWon = playerIndexOfUser === previousScoreRecord.winningPlayerIndex;\n            // update record if user has won and won in fewer rounds OR\n            // if user has never won and lasted more rounds before losing\n            doUpdateRecord =\n                (didUserWin &&\n                    (round < previousScoreRecord.round ||\n                        previousScoreRecord.round == 0)) ||\n                    (!didUserWin && !hasUserWon && round > previousScoreRecord.round);\n        }\n        else {\n            // if user vs user or bot vs bot just record latest score\n            doUpdateRecord = true;\n        }\n        if (doUpdateRecord) {\n            scoreRecords[playersIdentifer] = NewScoreRecord(Math.floor(round / 2), // round is realy game iteration (2 iterations = 1 round)\n            winningPlayerIndex);\n            localStorage.setItem(LOCAL_STORAGE_SCORE_RECORDS, JSON.stringify(scoreRecords));\n        }\n    };\n    const MakePlayerMove = async (x, y) => {\n        if (isPlayerMoving) {\n            return false;\n        }\n        isPlayerMoving = true;\n        const tile = GetTile(x, y);\n        const currentPlayerIndex = GetCurrentPlayerIndex();\n        let didPlayerMove = false;\n        if (tile.dots > 0 && tile.player === currentPlayerIndex) {\n            const dots = Math.min(tile.dots + 1, 4);\n            PlayerSetTile(x, y, (0, exports.NewTile)(dots, currentPlayerIndex));\n            renderCallbackHandler.triggerCallbacks();\n            await UpdateTiles();\n            didPlayerMove = true;\n        }\n        else if (tile.dots === 0 && round < 2) {\n            PlayerSetTile(x, y, (0, exports.NewTile)(3, currentPlayerIndex));\n            renderCallbackHandler.triggerCallbacks();\n            didPlayerMove = true;\n        }\n        isPlayerMoving = false;\n        if (didPlayerMove) {\n            UpdateGameIteration();\n        }\n        return didPlayerMove;\n    };\n    const CanPlayerMove = (x, y) => {\n        if (isPlayerMoving) {\n            return false;\n        }\n        const tile = GetTile(x, y);\n        const currentPlayerIndex = GetCurrentPlayerIndex();\n        if (tile.dots > 0 && tile.player === currentPlayerIndex) {\n            return true;\n        }\n        else if (tile.dots === 0 && round < 2) {\n            return true;\n        }\n        return false;\n    };\n    const LogBoard = () => {\n        const red = '\\x1b[31m';\n        const green = '\\x1b[32m';\n        const reset = '\\x1b[0m'; // Resets the color back to default\n        let boardStr = '';\n        for (let y = 0; y < _height; y++) {\n            for (let x = 0; x < _width; x++) {\n                const tile = GetTile(x, y);\n                if (tile.dots === 0) {\n                    boardStr += '# ';\n                }\n                else {\n                    boardStr += tile.player === types_1.PlayerIndex.One ? red : green;\n                    boardStr += tile.dots + reset + ' ';\n                }\n            }\n            boardStr += '\\n';\n        }\n        console.log(boardStr);\n    };\n    const GetWidth = () => {\n        return _width;\n    };\n    const GetHeight = () => {\n        return _height;\n    };\n    const GetTiles = () => {\n        return tiles;\n    };\n    const GetRound = () => {\n        return round;\n    };\n    const GetHasGameEnded = () => {\n        return hasGameEnded;\n    };\n    const GetPlayers = () => {\n        return players;\n    };\n    const state = {\n        MakePlayerMove,\n        GetWidth,\n        GetHeight,\n        GetTiles,\n        GetRound,\n        GetHasGameEnded,\n        GetPlayers,\n        LogBoard,\n        NewGame,\n        GetScoreRecords,\n        GetTile,\n        AddRenderCallback: renderCallbackHandler.addCallback,\n        AddNewRoundCallback: newRoundCallbackHandler.addCallback,\n        AddEndOfGameCallback: endOfGameCallbackHandler.addCallback,\n        GetCurrentPlayerIndex,\n        CanPlayerMove,\n        GetPlayerMoves,\n        TerminateGame,\n        SetTileUpdatePeriod: SetTileUpdatePeriod,\n        SetBotWaitPeriod\n    };\n    return state;\n};\nexports.CreateGame = CreateGame;\n\n\n//# sourceURL=webpack:///./src/front_end/game/main.ts?");

/***/ }),

/***/ "./src/front_end/game/types.ts":
/*!*************************************!*\
  !*** ./src/front_end/game/types.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PlayerType = exports.PlayerIndex = void 0;\nvar PlayerIndex;\n(function (PlayerIndex) {\n    PlayerIndex[PlayerIndex[\"One\"] = 0] = \"One\";\n    PlayerIndex[PlayerIndex[\"Two\"] = 1] = \"Two\";\n})(PlayerIndex || (exports.PlayerIndex = PlayerIndex = {}));\nvar PlayerType;\n(function (PlayerType) {\n    PlayerType[PlayerType[\"User\"] = 0] = \"User\";\n    PlayerType[PlayerType[\"Bot\"] = 1] = \"Bot\";\n})(PlayerType || (exports.PlayerType = PlayerType = {}));\n\n\n//# sourceURL=webpack:///./src/front_end/game/types.ts?");

/***/ }),

/***/ "./src/front_end/index.ts":
/*!********************************!*\
  !*** ./src/front_end/index.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// npx webpack --mode production\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst main_1 = __webpack_require__(/*! ./bot/main */ \"./src/front_end/bot/main.ts\");\nconst build_time_1 = __webpack_require__(/*! ./build_time */ \"./src/front_end/build_time.ts\");\nconst main_2 = __webpack_require__(/*! ./dom/main */ \"./src/front_end/dom/main.ts\");\nconst main_3 = __webpack_require__(/*! ./game/main */ \"./src/front_end/game/main.ts\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"./src/front_end/utils.ts\");\nconst Main = async () => {\n    console.log('Color Wars', { buildTime: (0, utils_1.FormatDate)(build_time_1.BUILD_TIME) });\n    const game = (0, main_3.CreateGame)();\n    const bot = (0, main_1.CreateBot)();\n    (0, main_2.InitialiseElementEvents)(game, bot);\n};\nMain();\n\n\n//# sourceURL=webpack:///./src/front_end/index.ts?");

/***/ }),

/***/ "./src/front_end/utils.ts":
/*!********************************!*\
  !*** ./src/front_end/utils.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.millisToMMSS = exports.NewCallbackHandler = exports.Sleep = exports.FormatDate = void 0;\nconst FormatDate = (date) => {\n    const pad = (num) => (num < 10 ? '0' + num : num.toString());\n    const day = pad(date.getDate());\n    const month = pad(date.getMonth() + 1);\n    const year = date.getFullYear().toString();\n    const hours = pad(date.getHours());\n    const minutes = pad(date.getMinutes());\n    return `${year}-${month}-${day} ${hours}:${minutes}`;\n};\nexports.FormatDate = FormatDate;\nconst Sleep = (ms) => {\n    return new Promise(resolve => setTimeout(resolve, ms));\n};\nexports.Sleep = Sleep;\nconst NewCallbackHandler = () => {\n    const callbacks = [];\n    // Method to add a callback\n    const addCallback = (callback) => {\n        if (typeof callback === 'function') {\n            callbacks.push(callback);\n        }\n        else {\n            console.error('Callback must be a function');\n        }\n    };\n    // Method to trigger the event\n    const triggerCallbacks = () => {\n        callbacks.forEach(callback => callback());\n    };\n    return {\n        addCallback,\n        triggerCallbacks\n    };\n};\nexports.NewCallbackHandler = NewCallbackHandler;\nconst addLeadingZeros = (num, totalLength) => {\n    return num.toString().padStart(totalLength, '0');\n};\nconst millisToMMSS = (millis) => {\n    const totalSeconds = Math.floor(millis / 1000);\n    const minutes = Math.floor(totalSeconds / 60);\n    const seconds = totalSeconds % 60;\n    return `${addLeadingZeros(minutes, 2)}:${addLeadingZeros(seconds, 2)}`;\n};\nexports.millisToMMSS = millisToMMSS;\n\n\n//# sourceURL=webpack:///./src/front_end/utils.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/front_end/index.ts");
/******/ 	
/******/ })()
;